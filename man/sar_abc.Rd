% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sarabc.R
\name{sar_abc}
\alias{sar_abc}
\title{SAR estimation using Aproximate Bayesian Computation}
\usage{
sar_abc(y, X, W, rho = runif(N, -1, 1), beta = matrix(runif(N * ncol(X), -2,
  2), nrow = N), sweights = c(1, 2, 2), N = 10000L, p = 5L,
  no_inv = FALSE, no_moran = FALSE, keep = 1000L, cl = NULL, ...)
}
\arguments{
\item{y}{Numeric vector of length \eqn{n}. Dependent variable.}

\item{X}{Numeric matrix of size \eqn{n\times k}{n*k}. Covariates.}

\item{W}{Square matrix of class \code{dgCMatrix} of size \eqn{n\times n}{n*n}.}

\item{rho}{Numeric vector of length \eqn{N}. Prior of \eqn{\rho}{rho}.}

\item{beta}{Numeric matrix of size \eqn{N\times k}{N*k}. Prior of \eqn{\beta}{beta}.}

\item{sweights}{Numeric vector of length 3. Weights for the distance.}

\item{N}{Integer scalar. Number of simulations to run.}

\item{p}{Integer scalar. See \code{\link{sar_sim}}.}

\item{no_inv}{Logical scalar. When \code{FALSE} runs the model approximating
the inverse of I_n - rho W. Otherwise naively predicts \eqn{y} as in OLS.}

\item{no_moran}{Logical scalar. When \code{TRUE} does not includes Moran's I
in the set of statistics to compute distances.}

\item{keep}{Numeric scalar between (0,1]. Sets what proportion of the simulated
data to keep after ranking according to distances.}

\item{cl}{An object generated by \code{\link[parallel:makeCluster]{makeCluster}}.}

\item{...}{Ignored.}
}
\value{
An object of class sar_abc
}
\description{
SAR estimation using Aproximate Bayesian Computation
}
\examples{
# Simple example ------------------------------------------------------------
set.seed(133)

# Parameters
n <- 200
rho  <- .25
beta <- -.6

# Dataset
W    <- netdiffuseR::rgraph_ws(n, 6, .15)
W    <- W/(Matrix::rowSums(W) + 1e-15)
X <- matrix(rnorm(n*1), ncol=1)
y <- sim_sar(W, X, rho, beta)

# Estimating
res <- sar_abc(y, X, W, N=1e4)
res

# Comparing with OLS
lm(y~0+I(as.matrix(W \%*\% y)) +X , data.frame(y,X))

# Comparing with sphet
\dontrun{
library(sphet)
spreg(y~X, data.frame(y,X), listw = mat2listw(W), model = 'lag')
}
}

